/**
 * @file fonts.c
 *
 * Fonts generated by the GLCD Creator Font This source code provides a C buffer
 * for small embedded systems and other useful information needed for better
 * display.
 *
 * MIT License
 *
 * Copyright (c) 2023 phonght32
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include "fonts.h"
#include "stdbool.h"

/*
 * @brief    Bit macro.
 */
#define FONT_BIT(x) 			((char)0x01 << x)

/*
 * @brief    ASCII offset.
 */
#define FONT_ASCII_OFFSET 		0x20

/*
 * @brief    Font 5x8 reference.
 */
extern const char font5x8_ref[FONT_5x8_NUM_MEMBER * FONT_5x8_NUM_BYTE];

/*
 * @brief    Font 9x16 reference.
 */
extern const char font9x16_ref[FONT_9x16_NUM_MEMBER * FONT_9x16_NUM_BYTE];

/*
 * @brief    Font 12x16 reference.
 */
extern const char font12x16_ref[FONT_12x16_NUM_MEMBER * FONT_12x16_NUM_BYTE];

/*
 * @brief    Font 14x30 reference.
 */
extern const char font14x30_ref[FONT_14x30_NUM_MEMBER * FONT_14x30_NUM_BYTE];

/*
 * @brief    Font 16x32 reference.
 */
extern const char font16x32_ref[FONT_16x32_NUM_MEMBER * FONT_16x32_NUM_BYTE];

/*
 * @brief    Font 25x57 reference.
 */
extern const char font25x57_ref[FONT_25x57_NUM_MEMBER * FONT_25x57_NUM_BYTE];

/*
 * @func    get_font
 */
int get_font(char c, font_size_t size, font_t *font)
{
	int idx, byte_per_row, num_row, max_width;

	if (font == NULL) {
		return -1;
	}

	switch (size) {
	case FONT_SIZE_5x8:
		byte_per_row = 1;
		num_row = 8;
		idx = c - FONT_ASCII_OFFSET;
		if (idx < 0 || idx > FONT_5x8_NUM_MEMBER) {
			return 0;
		}
		font->data_len = num_row * byte_per_row;
		font->height = num_row;
		font->ascii = c;
		memcpy(font->data, (char*)&font5x8_ref[idx * FONT_5x8_NUM_BYTE], font->data_len);

		if (font->ascii == 0x20) {
			font->width = 3;
			break;
		}

		max_width = 0;
		for (int row = 0; row < (int)font->height; row++) {
			int _width = 8 * byte_per_row;
			for (int bit = 0; bit < 8; bit++) {
				if ((font->data[row] & FONT_BIT(bit)) == FONT_BIT(bit)) {
					break;
				} else {
					_width--;
				}
			}
			max_width = (max_width < _width) ? _width : max_width;
		}
		font->width = max_width;
		break;

	case FONT_SIZE_9x16:
		byte_per_row = 2;
		num_row = 16;
		idx = c - FONT_ASCII_OFFSET;
		if (idx < 0 || idx > FONT_9x16_NUM_MEMBER) {
			return 0;
		}
		font->data_len = num_row * byte_per_row;
		font->height = num_row;
		font->ascii = c;
		memcpy(font->data, (char*)&font9x16_ref[idx * FONT_9x16_NUM_BYTE], font->data_len);

		if (font->ascii == 0x20) {
			font->width = 6;
			break;
		}

		max_width = 0;
		for (int row = 0; row < (int)font->height; row++) {
			int _width = 8 * byte_per_row;
			bool out = false;
			for (int byte = 1; byte > -1; byte--) {
				for (int bit = 0; bit < 8; bit++) {
					if ((font->data[byte + row * 2] & FONT_BIT(bit)) == FONT_BIT(bit)) {
						out = true;
						break;
					} else {
						_width--;
					}
				}
				if (out)
					break;
			}
			max_width = (max_width < _width) ? _width : max_width;
		}
		font->width = max_width;
		break;

	case FONT_SIZE_12x16:
		byte_per_row = 2;
		num_row = 16;
		idx = c - FONT_ASCII_OFFSET;
		if (idx < 0 || idx > FONT_12x16_NUM_MEMBER) {
			return 0;
		}
		font->data_len = num_row * byte_per_row;
		font->height = num_row;
		font->ascii = c;
		memcpy(font->data, (char*)&font12x16_ref[idx * FONT_12x16_NUM_BYTE], font->data_len);

		if (font->ascii == 0x20) {
			font->width = 6;
			break;
		}

		max_width = 0;
		for (int row = 0; row < (int)font->height; row++) {
			int _width = 8 * byte_per_row;
			bool out = false;
			for (int byte = 1; byte > -1; byte--) {
				for (int bit = 0; bit < 8; bit++) {
					if ((font->data[byte + row * 2] & FONT_BIT(bit)) == FONT_BIT(bit)) {
						out = true;
						break;
					} else {
						_width--;
					}
				}
				if (out)
					break;
			}
			max_width = (max_width < _width) ? _width : max_width;
		}
		font->width = max_width;
		break;

	case FONT_SIZE_14x30:
		byte_per_row = 2;
		num_row = 30;
		idx = c - FONT_ASCII_OFFSET;
		if (idx < 0 || idx > FONT_14x30_NUM_MEMBER) {
			return 0;
		}
		font->data_len = num_row * byte_per_row;
		font->height = num_row;
		font->ascii = c;
		memcpy(font->data, (char*)&font14x30_ref[idx * FONT_14x30_NUM_BYTE], font->data_len);

		if (font->ascii == 0x20) {
			font->width = 6;
			break;
		}

		max_width = 0;
		for (int row = 0; row < (int)font->height; row++) {
			int _width = 8 * byte_per_row;
			bool out = false;
			for (int byte = 1; byte > -1; byte--) {
				for (int bit = 0; bit < 8; bit++) {
					if ((font->data[byte + row * 2] & FONT_BIT(bit)) == FONT_BIT(bit)) {
						out = true;
						break;
					} else {
						_width--;
					}
				}
				if (out)
					break;
			}
			max_width = (max_width < _width) ? _width : max_width;
		}
		font->width = max_width;
		break;

	case FONT_SIZE_16x32:
		byte_per_row = 2;
		num_row = 32;
		idx = c - FONT_ASCII_OFFSET;
		if (idx < 0 || idx > FONT_16x32_NUM_MEMBER) {
			return 0;
		}
		font->data_len = num_row * byte_per_row;
		font->height = num_row;
		font->ascii = c;
		memcpy(font->data, (char*)&font16x32_ref[idx * FONT_16x32_NUM_BYTE], font->data_len);

		if (font->ascii == 0x20) {
			font->width = 6;
			break;
		}

		max_width = 0;
		for (int row = 0; row < (int)font->height; row++) {
			int _width = 8 * byte_per_row;
			bool out = false;
			for (int byte = 1; byte > -1; byte--) {
				for (int bit = 0; bit < 8; bit++) {
					if ((font->data[byte + row * 2] & FONT_BIT(bit)) == FONT_BIT(bit)) {
						out = true;
						break;
					} else {
						_width--;
					}
				}
				if (out)
					break;
			}
			max_width = (max_width < _width) ? _width : max_width;
		}
		font->width = max_width;
		break;

	case FONT_SIZE_25x57:
		byte_per_row = 4;
		num_row = 57;
		idx = c - FONT_ASCII_OFFSET;
		if (idx < 0 || idx > FONT_25x57_NUM_MEMBER) {
			return 0;
		}
		font->data_len = num_row * byte_per_row;
		font->height = num_row;
		font->ascii = c;
		memcpy(font->data, (char*)&font25x57_ref[idx * FONT_25x57_NUM_BYTE], font->data_len);

		if (font->ascii == 0x20) {
			font->width = 6;
			break;
		}

		max_width = 0;
		for (int row = 0; row < (int)font->height; row++) {
			int _width = 8 * byte_per_row;
			bool out = false;
			for (int byte = 1; byte > -1; byte--) {
				for (int bit = 0; bit < 8; bit++) {
					if ((font->data[byte + row * 2] & FONT_BIT(bit)) == FONT_BIT(bit)) {
						out = true;
						break;
					} else {
						_width--;
					}
				}
				if (out)
					break;
			}
			max_width = (max_width < _width) ? _width : max_width;
		}
		font->width = max_width;
		break;
	default:
		break;
	}
	return font->width;
}